function source_v1
    
    % NOTE: always run from the "analysis_scripts" folder, to ensure all relative
    % paths work as expected
    cd('D:\Judy\Exp1\6_MEG-data\analysis_scripts\Yokogawa_FT_v6_split');

    addpath(pwd); % allow access to scripts in this folder even after we cd into each SubjectFolder
    %addpath([pwd '\\coreg-master\\']); % allow access to coreg scripts

    % run the #define section
    global DataFolder; global ResultsFolder; global ResultsFolder_ROI;
    global eventnames; global conds_cue; global conds_target;
    common();

    % specify all paths as absolute paths here, because below we 'cd' into each
    % subject folder & the relative path will no longer be correct
    templates_dir = [pwd '\\..\\FT_templates\\']; % Location of the required templates (headmodel, grid & mri).
                                           % These usually come with the FT toolbox, but for ease of access
                                           % (consistent path across computers), I've stored a copy here.                                  
    MRI_folder = [pwd '\\..\\..\\..\\..\\MRI_databases\\HCP\\']; % location of your MRI database 
                                                                 % (consistent relative path across computers)
    SubjectFolders = listFolders(DataFolder);


    % each cycle processes one subject
    for h = 1:length(SubjectFolders)

        SubjectID = SubjectFolders{h};
        SubjectFolder = [DataFolder, '\\', SubjectID];
        cd(SubjectFolder); % change directory

        %% Step 1: coreg (to obtain individualised headmodel & mri)
        coreg_output = [pwd '\\MEMES\\']; % where to store the output from MEMES

        elp_file  = dir('*.elp'); % find the .elp file
        if isempty(elp_file) % not a subject folder, skip
            fprintf('%s: Not a subject folder - skip!', SubjectID);
            continue;
        end

        % if headmodel etc haven't been generated, do this now
        if ~exist([coreg_output 'headmodel_singleshell.mat'], 'file')
            % prepare all the inputs to MEMES
            temp = load([MRI_folder 'mesh_library.mat']);
            mesh_library = temp.mesh_library;
            initial_mri_realign = temp.initial_mri_realign;
            path_to_MRI_library = MRI_folder;

            filename_base = elp_file.name(1:strfind(elp_file.name,'.')-1); % get the base filename (ie. remove suffix)
            elpfile = [filename_base, '.elp'];
            hspfile = [filename_base, '.hsp'];
            confile = [filename_base, '_B1.con'];
            mrkfile = [filename_base, '_ini.mrk']; % choose which marker file to use

            MEMES(pwd,coreg_output,elpfile,hspfile,confile,mrkfile,path_to_MRI_library,mesh_library,initial_mri_realign);

            %mrifile = 'single_subj_T1.nii'; % use the template that comes with FT
            % don't use the dummy .mri file created by ME160 - it doesn't contain anything
            %coreg_yokogawa_icp(pwd, confile, mrkfile, mrifile, ...
            %    hspfile, elpfile, 100, 0.1); %[pwd,'\\',filename_base,'_MRI\\',filename_base,'.nii'], ...
            
        end
        
        % now load the headmodel & grads & mri generated by MEMES
        temp = load ([coreg_output 'headmodel_singleshell.mat']);
        headmodel = temp.headmodel_singleshell;
        temp = load ([coreg_output 'grad_trans.mat']);
        grads = temp.grad_trans;
        temp = load ([coreg_output 'mri_realigned_transformed.mat']);
        mri = temp.mri_realigned;


        %% Step 2: load this subject's ERF results
        subject_data = load([ResultsFolder SubjectID '_erf_noPCA.mat']);
        erf = subject_data.erf_clean;
        erf_cue_combined = subject_data.erf_cue_combined;
        erf_target_combined = subject_data.erf_target_combined;
        clear subject_data;

        %% only need this section if doing freq/time-freq analysis
        % (remember: erf is averaging then calc, freq is calc'ing on indi trials then average)
        % NOTE: you can do this elsewhere & simply load the results (just like you did above with the ERF results) 
    %{

        load trials_clean   % trials_clean is after visual rejection & just before ft_timelockanalysis in Yokogawa_FT_v5
        data = trials_clean.cue;

        % we saved the bad trials as NaN, so need to exclude these
        good_trials_idx = find(~isnan(cell2mat(cellfun(@(isgood)isgood(1),data.trial,'uni',0)))); %just need to evaluate the first element as all samples in bad trial are NaN

        cfg        = [];
        cfg.trials = good_trials_idx;
        data       = ft_redefinetrial(cfg, data);


        %% Bandpass Filter (to get the required freq range)
        cfg           = [];
        cfg.channel   = 'all';
        cfg.bpfilter  = 'yes';
        cfg.bpfreq    = [7 12];    % keep alpha only
        data_filtered = ft_preprocessing(cfg,data);


        %% Here we redefine trials based on the time-points of interest.
        % Make sure the timepoints are of equivalent length - no need to do this
        % but I'm leaving it here anyway
        cfg        = [];
        cfg.toilim = [-0.4 0]; % baseline window
        datapre    = ft_redefinetrial(cfg, data_filtered);

        cfg.toilim = [0.3 0.7]; % window of interest
        datapost   = ft_redefinetrial(cfg, data_filtered);

        % Here we are keeping all parts of the trial for your covariance matrix
        % **SHOULD THIS GO AFTER AVERAGE?***
        cfg                  = [];
        cfg.covariance       = 'yes';
        cfg.covariancewindow = [-1.0 1.0];
        avg                  = ft_timelockanalysis(cfg,data_filtered);

        % Time lock analysis for datapre and datapost period
        cfg                  = [];
        cfg.covariance       = 'yes';
        %cfg.covariancewindow = [-1.0 1.0];
        avgpre               = ft_timelockanalysis(cfg,datapre);
        avgpst               = ft_timelockanalysis(cfg,datapost);
    %}    


        %% Step 3: prepare sourcemodel & leadfield

        % Load template brain MNI space
        %template_mri          = ft_read_mri(fullfile(templates_dir, 'template\\anatomy\\single_subj_T1_1mm.nii')); %This is the standard which matches AAL space
        %template_mri.coordsys = 'nifti_spm'; % So that FieldTrip knows how to interpret the coordinate system
        
        % Create template grid (aka. template sourcemodel)
        % Method 1:
        %{
        % Load template headmodel
        load([templates_dir, 'standard_singleshell']);
        template_headmodel = vol; % rename the loaded variable                                     
        template_headmodel = ft_convert_units(template_headmodel, 'cm'); % convert headmodel into standard units (CTF convention is to express everything in cm)

        % create template sourcemodel using template headmodel
        cfg             = [];
        cfg.grid.xgrid  = -20:0.5:20; % x-axis range: -20 ~ 20cm, step 0.5cm (change this value to adjust reso)
        cfg.grid.ygrid  = -20:0.5:20;
        cfg.grid.zgrid  = -20:0.5:20;
        cfg.grid.unit   = 'cm';
        cfg.grid.tight  = 'yes';
        cfg.inwardshift = -0.1;
        cfg.headmodel   = template_headmodel;
        template_sourcemodel = ft_prepare_sourcemodel(cfg);
        %}
        % Method 2: load the template sourcemodel provided by FT
        load([templates_dir, 'standard_sourcemodel3d5mm']); % usually 10mm grid is fine.
                                                            % here we use a higher resolution grid (5mm),
                                                            % to increase the number of vertices assinged to
                                                            % the parcel 'Frontal_Med_Orb_L' (in AAL atlas)
                                                            % Otherwise it only contains 3 vertices - not enough to compute centroid!
        template_sourcemodel = sourcemodel; % rename the loaded variable
        clear sourcemodel;
        
        % Warp template grid into subject space
        cfg                = [];
        cfg.grid.warpmni   = 'yes';
        cfg.grid.template  = template_sourcemodel; % standard sourcemodel
        cfg.grid.nonlinear = 'yes';
        cfg.mri            = mri; % individual mri
        sourcemodel = ft_prepare_sourcemodel(cfg); % creates individual sourcemodel

        % Plots for sanity checks
        % plot headmodel, grid, and mri
        %{        
        ft_determine_coordsys(mri, 'interactive','no'); hold on
        ft_plot_vol(headmodel);
        ft_plot_mesh(sourcemodel.pos(sourcemodel.inside,:));
        %}           
        % plot headmodel, grid, and sensor locations
        %{
        figure;
        ft_plot_sens(grads, 'style', '*b'); % plot the MEG sensor locations
        ft_plot_vol(headmodel, 'edgecolor', 'cortex'); alpha 0.4; % plot the single shell (i.e. brain shape)
        ft_plot_mesh(sourcemodel.pos(sourcemodel.inside,:)); % plot all vertices (ie. grid points) that are inside the brain
        %}

        % Create the leadfield
        cfg            = [];
        cfg.grad       = grads;
        cfg.headmodel  = headmodel; % individual headmodel (from coreg)
        cfg.reducerank = 2; % Should check this is appropriate - also check the rank of the data as we project out mouth artifacts earlier
        cfg.channel    = erf_cue_combined.label; % use the actual channels present in our data (i.e. ensure that rejected sensors are also removed here)
        cfg.grid       = sourcemodel; % individual sourcemodel
        [grid]    = ft_prepare_leadfield(cfg); % sourcemodel + leadfield


        %% Step 4: LCMV beamformer
        % http://www.fieldtriptoolbox.org/tutorial/salzburg
        % http://www.fieldtriptoolbox.org/example/common_filters_in_beamforming

        % Create common spatial filter (based on data across all conds),
        % otherwise it would be circular (diff filters for diff conds, created based on each cond)
    %{    
        % first, compute the average erf (across 4 conds) for cue window & target window
        erf_cue_combined = erf.cuechstay; % average erf for cue window
        erf_cue_combined.avg = (erf.cuechstay.avg + erf.cuechswitch.avg + erf.cueenstay.avg + erf.cueenswitch.avg) / 4;
        erf_target_combined = erf.targetchstay; % average erf for target window
        erf_target_combined.avg = (erf.targetchstay.avg + erf.targetchswitch.avg + erf.targetenstay.avg + erf.targetenswitch.avg) / 4;
    %}    
        % run ft_sourceanalysis on the cue_combined erf & target_combined erf
        % to create common spatial filters (1 filter for cue, 1 filter for target)
        cfg                 = [];
        cfg.keeptrials      = 'no';
        cfg.channel         = 'MEG';
        cfg.grad            = grads;
        cfg.senstype        = 'MEG';
        cfg.method          = 'lcmv';
        cfg.grid            = grid; % sourcemodel + leadfield
        cfg.grid.unit       = 'cm';
        cfg.headmodel       = headmodel; % individual headmodel (from coreg)
        cfg.lcmv.lamda      = '5%';
        cfg.lcmv.fixedori   = 'yes';
        cfg.lcmv.keepfilter = 'yes';
        cfg.lcmv.projectmom = 'no';
        cfg.lcmv.normalize  = 'yes'; %corrects for depth bias?
        source_cue_combined = ft_sourceanalysis(cfg, erf_cue_combined); % create spatial filter for cue window
        source_target_combined = ft_sourceanalysis(cfg, erf_target_combined); % create spatial filter for target window

        % now use the common spatial filter to run source analysis for each cond
        % Note: ft_sourceanalysis is only for illustration purpose (no time dimension, only creates a source image showing where in the 3d space is one cond different from another cond)
        %{    
        % 4 conds in cue window
        cfg.grid.filter = source_cue_combined.avg.filter;
        for j = conds_cue
            source.(eventnames{j}) = ft_sourceanalysis(cfg, erf.(eventnames{j}));
        end

        % 4 conds in target window
        cfg.grid.filter = source_target_combined.avg.filter; 
        for j = conds_target
            source.(eventnames{j}) = ft_sourceanalysis(cfg, erf.(eventnames{j}));
        end


        %% Compute Percentage Power Change From Baseline
        sourceDiff         = sourcepst;
        sourceDiff.avg.pow = (sourcepst.avg.pow - sourcepre.avg.pow) ./ sourcepre.avg.pow;

        %load template for display in MNI sapce and replace subject grid with MNI
        %grid
        template_mri   = ft_read_mri(templatefile);
        sourceDiff.pos = template_sourcemodel.pos;

        %Smear the point solution into an MRI overlay
        cfg              = [];
        cfg.voxelcoord   = 'no';
        cfg.parameter    = 'pow';
        cfg.interpmethod = 'nearest';
        source_int       = ft_sourceinterpolate(cfg, sourceDiff, template_mri);

        %Finally, we can plot the result using ft_sourceplot.
        cfg              = [];
        cfg.method       = 'ortho';
        cfg.funparameter = 'pow';
        %cfg.funcolorlim  = [-0.1 0.1]; % Do this programmatically
        cfg.opacitylim   = 'zeromax';
        cfg.location     = [64 -32 8];
        cfg.funcolormap  = 'jet';
        ft_sourceplot(cfg,source_int);

        save([filename_base,'_source_int_alpha'],'source_int')

        %% Export to nifti format
        cfg           = [];
        cfg.filetype  = 'nifti';
        cfg.filename  = filename_base;
        cfg.parameter = 'pow';
        ft_sourcewrite(cfg,source_int);
        %}

        %% Step 5: ROI analysis
        % Here we use the atlas to create VEs (virtual sensors) - 1 VE represents 1 ROI

        % Load Atlas (contains parcellation of brain into regions/tissues/parcels)
        atlas = ft_read_atlas(fullfile(templates_dir, 'ROI_MNI_V4.nii'));
        atlas = ft_convert_units(atlas, 'cm');% ensure that atlas and template_sourcemodel are expressed in the same units

        % Interpolate the atlas onto template sourcemodel (10mm grid),
        % because the atlas may not be at the same resolution as your grid
        % (e.g. you created a grid with 6000 vertices, but atlas may only have 2000 vertices)
        cfg                  = [];
        cfg.interpmethod     = 'nearest';
        cfg.parameter        = 'tissue';
        atlas_interpo = ft_sourceinterpolate(cfg, atlas, template_sourcemodel);

        % Add the tissue labels from atlas to our sourcemodel
        % (each "tissue label" defines one "parcel")
        sourcemodel.tissue      = atlas_interpo.tissue; 
        sourcemodel.tissuelabel = atlas_interpo.tissuelabel;


        % Define our ROIs (can combine multiple parcels together to form one ROI)
        ROIs = {{'Frontal_Inf_Oper_L';'Frontal_Inf_Tri_L'},{'Frontal_Inf_Oper_R';'Frontal_Inf_Tri_R'},...
            {'Temporal_Sup_L'},{'Temporal_Sup_R'},{'Supp_Motor_Area_L'},{'Supp_Motor_Area_R'},...
            {'Cingulum_Ant_L'},{'Cingulum_Ant_R'},{'Frontal_Med_Orb_L'},{'Frontal_Med_Orb_R'}...
            {'Calcarine_L';'Calcarine_R'}};

        ROIs_label = {'LIFG','RIFG','LSTG','RSTG','LSMA','RSMA','LACC','RACC','LdlPFC','RdlPFC','V1'}; %Labels for the groupings
        % Not too sure about the dlPFC (BA9, 10, 46) <- I chose 'medial orbitofrontal cortex', 
        % plot seems to include entire middle frontal gyrus and a bit of BA10;
        % alternatively, we could use 'Frontal_Mid_L' (middle frontal gyrus).
        % For more precise definition of preSMA, 
        % try (1) Stanford FIND parcellation (2) HMAT


        % Make a plot showing the vertices in the parcels on the source model - a good sanity check 
        %{
        % to plot selected ROIs only:
        %ROIs = {{'Frontal_Med_Orb_R'},{'Cingulum_Ant_R'},{'Frontal_Med_Orb_L'},{'Frontal_Med_Orb_R'}};       

        figure('Name','Position of Points','NumberTitle','off'); hold on;
        ft_plot_vol(headmodel,  'facecolor', 'cortex', 'edgecolor', 'none','facealpha',0.4);
        hold on;

        % draw the ROIs
        parcel_vertices = [];
        for e = 1:length(ROIs)
            indx_pos = [];
            for region = find(ismember(sourcemodel.tissuelabel, char(ROIs{e})))
                % Get atlas points
                indx = (find(sourcemodel.tissue == region));
                for vol = 1:length(indx)
                    indx_pos_temp(vol,:) = sourcemodel.pos(indx(vol),:); % take the warped coords
                end
                indx_pos = vertcat(indx_pos, indx_pos_temp);
            end
            ft_plot_mesh(indx_pos, 'vertexcolor','k', 'vertexsize',20); hold on; drawnow; pause(0.2);
            title(sourcemodel.tissuelabel(region), 'Interpreter', 'none');
            parcel_vertices.(ROIs_label{e}) = indx_pos; %creates a struct with the vertices for each ROI being used. Might be useful at some point
        end
        %}

        
        %% Create VE for each ROI
                
        % Each cycle deals with one ROI
        for k = 1:length(ROIs)
            ROI_name = ROIs_label{k};
            
            % for this ROI, find a list of vertices that belong to it, and
            % extract the spatial filter for each vertex in cue window & target window
            vertices_all = []; % will hold a single list of all vertices (from all parcels belonging to this ROI)
            for j = 1:length(ROIs{k})
                indx        = find(ismember(sourcemodel.tissuelabel, ROIs{k}{j})); % find index of the required tissue label
                vertices    = find(sourcemodel.tissue == indx); % find vertices that belong to this tissue label
                % add vertices from the current parcel to the overall list
                vertices_all = [vertices_all; vertices];
            end
            % for each vertex, get the spatial filter (i.e. set of weights) for it
            vertices_filters_cue = cat(1, source_cue_combined.avg.filter{vertices_all}); 
            vertices_filters_target = cat(1, source_target_combined.avg.filter{vertices_all});

            
            % create virtual sensor for this ROI in cue window
            %VE = create_virtual_sensor_Centroid(ROI_name, vertices_all, vertices_filters_cue, erf_cue_combined, erf, conds_cue, headmodel, sourcemodel);
            VE = create_virtual_sensor_SVD(ROI_name, vertices_filters_cue, erf_cue_combined, erf, conds_cue); 
            if ~isempty(VE) % successful
                ROI_activity.(ROI_name) = VE;
            else
                fprintf(['No solution for ', ROI_name, ' in cue window.']);
            end
            
            % create virtual sensor for this ROI in target window
            %VE = create_virtual_sensor_Centroid(ROI_name, vertices_all, vertices_filters_target, erf_target_combined, erf, conds_target, headmodel, sourcemodel);
            VE = create_virtual_sensor_SVD(ROI_name, vertices_filters_target, erf_target_combined, erf, conds_target);
            if ~isempty(VE) % successful
                for j = conds_target  % append to existing cue-window results
                    ROI_activity.(ROI_name).(eventnames{j}) = VE.(eventnames{j});
                end
            else
                fprintf(['No solution for ', ROI_name, ' in target window.']);
            end
        end
                    
        save([ResultsFolder_ROI SubjectID '_ROI.mat'], 'ROI_activity');

        % Plot the source activity at each ROI
        %{
        for k = 1:length(ROIs)
            ROI_name = (ROIs_label{k});
            
            % plot for cue window
            figure; hold on; 
            title(['Cue window: ' ROI_name]);
            for j = conds_cue
               plot(ROI_activity.(ROI_name).(eventnames{j}).time, ROI_activity.(ROI_name).(eventnames{j}).avg);
               xlim([-0.2 0.75]); % epoch was [-1 1], we only want to plot [-0.2 0.75]
            end
            legend(eventnames(conds_cue));
            
            % plot for target window
            figure; hold on; 
            title(['Target window: ' ROI_name]);
            for j = conds_target
               plot(ROI_activity.(ROI_name).(eventnames{j}).time, ROI_activity.(ROI_name).(eventnames{j}).avg);
               xlim([-0.2 0.75]); % epoch was [-1 1], we only want to plot [-0.2 0.75]
            end
            legend(eventnames(conds_target));
        end
        %}


        %% Step 6: stats
%{
        % Q1: do stats across subjects?
        A: yes. Plot grand ave first, just to get an idea of what effect is there. Then run stats.
        
        % Q2. use ft_timelockstatistics (exactly the same way as doing stats on erf)?
        A: yes.
        % (but ft_timelockstats takes in erf structures, here we don't have the .avg field, just naked data)
        A: either hack it, or use EEGlab (statcond, std_stat).

        Done: Implemented in stats_ROI.m
%}
    end



    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % SUBFUNCTIONS
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % retrieve the xyz-coordinates of the given vertices
    function coordinates = get_coordinates_for_vertices(sourcemodel, vertices)
        % each cycle processes one vertex
        for i = 1:length(vertices)
            coordinates(i,:) = sourcemodel.pos(vertices(i), :); %take the warped coordinates
        end

        % alternative method:
        %coordinates = sourcemodel.pos(vertices,:);
    end

    % Load coordinates of centroids from file, then warp into subject space
    % (in preparation for calling create_virtual_sensor_Centroid)
    %
    % @param mri_realigned: correctly realigned MRI file
    % 
    % @output pos_grid: centres of mass in individual space
    %
    function pos_grid = load_centroids(templates_dir, mri_realigned)
        % Load centre of mass information (in mm)
        % These coordinates were generated using:
        % https://github.com/mingruixia/BrainNet-Viewer/blob/master/BrainNet_GenCoord.m
        centre_of_mass = load([templates_dir 'Node_AAL116.txt']);

        % convert mri to mm for consistency
        mri_realigned = ft_convert_units(mri_realigned, 'mm');

        % Align centres of mass into subject space 
        % I.e. we are performing inverse non-linear warping from MNI-->individual
        %cfg = [];
        %cfg.template = fullfile(templates_dir, 'single_subj_T1.nii'); % template brain in MNI space (matches AAL atlas)
        %cfg.nonlinear   = 'yes';
        norm = ft_volumenormalise([], mri_realigned); % transformation matrix from MNI <--> individual
        posback = ft_warp_apply(norm.params, centre_of_mass, 'sn2individual');
        pos_grid = ft_warp_apply(pinv(norm.initial), posback); % xyz-coordinates of each parcel's centre of mass, in individual space

        % convert back to cm
        pos_grid = pos_grid./10; 
    end

    % plot vertices & centroid in the given ROI
    function plot_ROI_centre_of_mass(ROI_name, vertices_coords, centroid, headmodel_singleshell)

        figure('Name',ROI_name, 'NumberTitle','off'); hold on;
        ft_plot_vol(headmodel_singleshell,  'facecolor', 'cortex', 'edgecolor', 'none');
        alpha 0.5; camlight; hold on;

        try           
            ft_plot_mesh(vertices_coords, 'vertexcolor','blue', 'vertexsize',10); hold on;
            ft_plot_mesh(centroid, 'vertexcolor','red', 'vertexsize',30); hold off;
        catch
            fprintf('In ROI "%s": Cannot plot vertices & centroid.\n', ROI_name);
        end
    end

    % create a virtual sensor for the given ROI (based on the spatial filter
    % for each vertex within the ROI), to estimate its activity
    %
    % uses Centroid method for collapsing all vertices within the ROI into a single VE
    %
    % @param vertices:      a list of vertices within this ROI (specified by their vertex index)
    % @param vertices_filters: a list of vertices within this ROI, each entry contains the spatial filter (set of weights) for one vertex
    % @param erf_combined:  average erf across all 4 conditions
    % @param erf:           separate erf for each condition
    %
    function VE = create_virtual_sensor_Centroid(ROI_name, vertices, vertices_filters, erf_combined, erf, conds, headmodel, sourcemodel)

        % compute the coordinates of the centroid
        vertices_coords = get_coordinates_for_vertices(sourcemodel, vertices); % coordinates are in cm
        centroid = find_centroid(vertices_coords); % compute the centroid of this ROI 
        %plot_ROI_centre_of_mass(ROI_name, vertices_coords, centroid, headmodel); % for quality check


        % Create VE by collapsing the activities at all vertices within ROI into one timecourse,
        % weighting the activity at each vertex based on its distance from centre of mass
        %
        %"To generate a single regional timecourse, individual voxel signals
        % were weighted according to their distance from the centre of mass"
        % Brookes et al., (2016)

        VE = [];

        % if there are any vertices in this ROI, create virtual sensor to represent this ROI
        if ~isempty(vertices_filters)
            for i = conds
                % put it into a timelock structure for later calling ft_timelockstatistics (in stats_ROI.m)
                VE.(eventnames{i}).time = erf_combined.time;
                VE.(eventnames{i}).label = {ROI_name};
                VE.(eventnames{i}).dimord = 'chan_time';

                % a list of reconstructed source activities, one for each vertex
                timecourses = vertices_filters(:,:) * erf.(eventnames{i}).avg(:,:); % estimated source activity = filter * erf (i.e. s = w * X) 

                % weight the timecourse for each vertex by its distance to centre
                timecourses_weighted = [];
                for vertex = 1:size(vertices_coords,1) % each cycle processes one vertex
                    distance = pdist([vertices_coords(vertex,:).*10 ; centroid.*10]); % calculate distance to centre in mm
                    timecourses_weighted(vertex,:) = exp((-distance.^2)./400) .* timecourses(vertex,:); % weight
                end

                % take the mean of all the weighted timecourses (i.e. collapse into one timecourse)
                VE.(eventnames{i}).avg = mean(timecourses_weighted, 1);
            end

            % Preserve .sampleinfo field to avoid warnings later
            %VE.sampleinfo = data.sampleinfo;
        end    
    end    

    % create a virtual sensor for the given ROI (based on the spatial filter
    % for each vertex within the ROI), to estimate its activity
    %
    % uses SVD method for collapsing all vertices within the ROI into a single VE
    %
    % @param vertices_filters: a list of vertices within this ROI, each entry contains the spatial filter (set of weights) for one vertex
    % @param erf_combined:  average erf across all 4 conditions
    % @param erf:           separate erf for each condition
    %
    function VE = create_virtual_sensor_SVD(ROI_name, vertices_filters, erf_combined, erf, conds)
        VE = [];

        % if there are any vertices in this ROI, create virtual sensor to represent this ROI
        if ~isempty(vertices_filters)
            % we want to combine the spatial filters for all vertices in this ROI into one filter
            % We do this by performing PCA on concatenated filters * sensor-level cov matrix
            F       = vertices_filters; % make a shorthand
            [u,s,v] = svd(F * erf_combined.cov * F'); % Inner dimensions = number of channels i.e. 125 for KIT child system
            filter  = u' * F;

            % Create VE using this filter
            %VE.label = {ROI_name};
            for i = conds
                % put it into a timelock structure for later calling ft_timelockstatistics (in stats_ROI.m)
                VE.(eventnames{i}).time = erf_combined.time;
                VE.(eventnames{i}).avg(1,:) = filter(1,:) * erf.(eventnames{i}).avg(:,:); % estimated source activity = filter * erf (i.e. s = w * X)
                VE.(eventnames{i}).label = {ROI_name};
                VE.(eventnames{i}).dimord = 'chan_time';
            end

            % Preserve .sampleinfo field to avoid warnings later
            %VE.sampleinfo = data.sampleinfo;


            % only for time-freq analysis
            %{
            %    tfve_plot = figure;
            %    ve_plot   = figure;

            % Create TFR of the VE
            cfg         = [];
            cfg.channel = 'all';
            cfg.method  = 'wavelet';
            cfg.width   = 7;
            cfg.output  = 'pow';
            cfg.foi     = freqband(1):0.25:freqband(2);
            cfg.toi     = -1.0:0.05:1.0; % Need to clean these time windows up for consistency
            cfg.pad     = 'nextpow2';
            TFRwave     = ft_freqanalysis(cfg, eval(ROIs_label{k}));
            save([fname,'_',ROIs_label{k},'_TFRwave_beta'],'TFRwave')

            % Plot
            figure(tfve_plot)
            subplot(4,2,k)
            cfg          = [];
            cfg.ylim     = freqband;
            cfg.baseline = [-0.6 -0.1]; % To do : fix time windows
            cfg.xlim     = [-0.2 1.0];
            ft_singleplotTFR(cfg, TFRwave);
            title(sprintf('%s',ROIs_label{k}));
            colormap(colours)

            figure(ve_plot);
            cfg      = [];
            cfg.xlim = [-0.2 1];
            eval([ROIs_label{k},'_avg_VE_beta           = ft_timelockanalysis(cfg,',ROIs_label{k},');']);
            subplot(4,2,k)
            eval(['ft_singleplotER(cfg,',ROIs_label{k},'_avg_VE_beta)']) % Could add smooth here
            save([fname,'_',ROIs_label{k},'_avg_VE_beta'],[ROIs_label{k},'_avg_VE_beta'])
            %}
        end
    end    

end % main function end